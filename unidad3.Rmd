---
title: "Pr√°ctica de la **Unidad 3. Procesamiento de datos**"
subtitle: "Del Curso introductorio al lenguaje de programaci√≥n R orientado al an√°lisis cuantitativo en Ciencias Sociales"
author: "Por Sarah√≠ Aguilar"
output:
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br>

[üè†‚Ü© De vuelta a la p√°gina principal del curso](index.html)

<br>

## Inicio

> #### **üöÄ Objetivo de la unidad** 
Que el estudiante sea capaz de importar y exportar conjuntos de datos de y en diferentes formatos, as√≠ como ejecutar transformaciones b√°sicas sobre estas utilizando dataframes y el paquete data.table.

<br>

[**üóÇ ‚¨á Descargar datos a utilizar en la pr√°ctica y los ejercicios**](data/packages/unidad3_data.zip)

* Los archivos pob_censo_2020_inegi.csv, pob_censo_2020_inegi.txt y pob_censo_2020_inegi.xlsx contienen el mismo conjunto de datos de poblaci√≥n de hombres y mujeres por entidad federativa y edad. La fuente de los datos es el [Censo de Poblaci√≥n y Vivienda 2020 del INEGI]("https://www.inegi.org.mx/programas/ccpv/2020/"). 

* El archivo pob_censo_2020_inegi.csv contiene datos de poblaci√≥n de hombres y mujeres que estudiaron una licenciatura (o equivalente) por entidad federativa y edad. La fuente de los datos es el [Censo de Poblaci√≥n y Vivienda 2020 del INEGI]("https://www.inegi.org.mx/programas/ccpv/2020/").

<br/>

[**üá∑ ‚¨á Descargar projecto de R de la pr√°ctica y los ejercicios resueltos**](projs/unidad3.zip)

<br>

## 3.1. Instalando y cargando paquetes

Las siguientes instrucciones descargan los paquetes que utilizaremos en la pr√°ctica a tu equipo de c√≥mputo. Por lo tanto, solo se debe correr una √∫nica vez (por equipo de c√≥mputo).
```{r}
# install.packages("data.table")
# install.packages("curl")
# install.packages("readxl")
# install.packages("foreign")
```

<br>
Cargando un paquete
Esta instrucci√≥n carga las funciones de los paquetes que utilizaremos a tu sesi√≥n de R actual. Por lo tanto, debemos correrla cada que vayamos a utilizar las funciones del paquete en una nueva sesi√≥n de R.
```{r}
library(data.table)
library(readxl)
library(foreign)
```

<br>

## 3.2. Creando un data table

* Desde 0

Recuerde que un data frame (y por lo tanto, un data table tambi√©n) se compone de vectores. En el siguiente bloque de c√≥digo, se instancian dos vectores inicialmente para despu√©s utilizarlos al crear un nuevo data table desde 0.
üí° Recordemos que los data tables heredan todas las propiedades de un data frame. 
```{r}
x <- 1:200
y <- rnorm(200, mean = 70, sd = 10)
dt <- data.table(id = x, age = y) 
```
Es importante denotar que los vectores que conformaran las columnas de un data table al crearlo desde 0, deben ser del mismo tama√±o.  

<br>

* A partir de un data frame

Para convertir un dataframe a un datatable, utilizamos la misma funci√≥n que empleamos para instanciar un data table desde 0.
```{r}
x <- 1:200
y <- rnorm(200, mean = 70, sd = 10)
df <- data.frame(id = x, age = y ) 
dt <- data.table(df)
```

<br>

* A partir de un archivo con formato tabular

Utilizamos la funci√≥n ```fread()```, que lee y convierte el contenido del archivo en un data table.  
üí° El formato *ideal* para leer y escribir datos en un entorno de desarrollo orientado al an√°lisis de conjuntos de datos (como R) es el csv ("valores separados por comas" por sus siglas en ingl√©s).
```{r}
dt <- fread("./data/pob_censo_2020_inegi.csv", encoding = "UTF-8")
```
Note que la ruta para leer el archivo comienza en el directorio de trabajo de RStudio y que termina con el nombre completo (incluyendo sufijo) del archivo.

üí° El par√°metro `enconding` de la funci√≥n `fread()` permite especificar una codificaci√≥n de caracteres Unicode. La codificaci√≥n [UTF-8(https://es.wikipedia.org/wiki/UTF-8) es la que com√∫nmente se utiliza para la correcta lectura de acentos y otros caracteres especiales en spa√±ol. 

<br>
Tambi√©n es posible utilizar hiperv√≠nculos como ruta de lectura de un archivo. 
```{r}
dt_link <- fread("https://raw.githubusercontent.com/sarahiaguilar/R-4-SocialSci/gh-pages/data/pob_censo_2020_inegi.csv")
```

<br>
La funci√≥n fread tiene par√°metros que facilita la lectura de archivos con formatos m√°s complejos. 
üí° Recuerde que para conocer m√°s acerca de una funci√≥n espec√≠fica (incluyendo sus par√°metros y valores por defecto), corra "?" + el nombre de la funci√≥n. 

Por ejemplo, si el archivo no contiene un encabezado (nombres de columnas), podemos utilizar el par√°metro `header` para indicarlo, o si el archivo est√° separado por un caracter distinto a una coma, podemos utilizar el par√°metro `sep` para indicarlo.
```{r}
dt_txt <- fread("./data/pob_censo_2020_inegi.txt", header = FALSE, sep = ";")
```

<br>
Para archivos xlsx utilizamos la funci√≥n `read_xlsx` del paquete `readxl`. Es necesario indicar como par√°metro de esta funci√≥n el n√∫mero de hoja que deseamos leer. Tambi√©n, es importante destacar que esta funci√≥n, a diferencia de la funci√≥n `fread()`, no convierte el contenido del archivo en un data table, por lo que es necesario hacer dicha conversi√≥n posteriormente. 
```{r}
df_xlsx <- read_xlsx("./data/pob_censo_2020_inegi.xlsx", sheet = 1) # Lee hoja n√∫mero 1
df_xlsx <- data.table(df_xlsx) # Convierte a data table
```

<br>
Para archivos sav de SPSS o dta de STATA utilizamos funciones del paquete `foreign`. 
```{r}
# df_spss <- read.spss("example.sav", to.data.frame = TRUE, use.value.labels = FALSE)
# df_stata <- read.dta("example.dta")
```

<br>

## 3.3. Exportando un data table

Para exportar un data table utilizamos la funci√≥n `write.csv()` de R Base, que recibe como par√°metro el objeto del data table que deseamos exportar y la ruta para escribir el archivo, que comienza en el directorio de trabajo de RStudio y termina con el nombre completo (incluyendo sufijo) del archivo. 
```{r}
# write.csv(dt, file = "./data/new_pob_censo_2020_inegi.xlsx", row.names = FALSE)
```

Por defecto, la funci√≥n `write.csv()` escribir√° el data table con una variable adicional de √≠ndice. El par√°metro `row.names` permite definir si queremos o no agregar dicha variable adicional al escribir el data table.  

<br>

## 3.4. Conociendo a un data table
<center>
![](https://i.pinimg.com/originals/db/ef/7d/dbef7ded446bf28e9f258b1edc7d3399.gif)
</center>

<br>
Las siguientes funciones nos permiten explorar r√°pidamente la composici√≥n de un data table. Este es un paso crucial para tener un entendimiento general de "c√≥mo luce" el conjunto de datos y qu√© tipo de procesamiento requeriremos hacer sobre √©l.

üí° Es buena pr√°ctica mantener nuestro ambiente libre de variables que ya no vamos a utilizar. Es posible eliminar variables desde nuestro ambiente desde la ventana de `Environment` de RStudio, pero tambi√©n es posible con la funci√≥n `rm()`.

```{r}
rm(df, df_xlsx, dt_link, dt_txt, x, y)
```

<br>
Las siguientes funciones nos permiten explorar

<br>
La funci√≥n ```head()``` devuelve las primeras 6 observaciones de un data table.
```{r}
head(dt)
```

<br>
La funci√≥n ```tail()``` devuelve las √∫ltimas 6 observaciones de un data table. 
```{r}
tail(dt)
```

<br>
Tanto ```head()``` como ```tail()```, pueden recibir el argumento adicional ```n```, que indicar√° cu√°ntas observaciones devolver√°. 
```{r}
tail(dt, n=2) # Imprime las 2 √∫ltimas observaciones
```

<br>
La funci√≥n ```colnames()``` devuelve los nombres de las variables de un data table. 
```{r}
colnames(dt)
```

<br>
La funci√≥n ```dim()``` devuelve un vector de tama√±o 2 con las dimensiones del data table. En la primer posici√≥n del vector, se devolver√° el n√∫mero de observaciones, y en la segunda posici√≥n, el n√∫mero de variables.  
```{r}
dim(dt)
```

<br>
La funci√≥n ```nrow()``` devuelve el n√∫mero de observaciones, y la funci√≥n `ncol()`, el n√∫mero de variables.  
```{r}
nrow(dt)
```

<br>
```{r}
ncol(dt)
```

<br>
La funci√≥n ```str()``` devuelve el tipo y tama√±o de cada vector que compone a un data table A esto se le conoce como la "estructura" de un data frame. 
```{r}
str(dt)
```

<br>
La funci√≥n ```summary()``` devuelve algunas de las medidas de dispers√≥n de las variables num√©ricas de un data table e incluso el n√∫mero de `NA`s por columna (en caso de que haya). 
```{r}
summary(dt)
```

<br>
**Para data tables no muy grandes**, podemos utilizar la funci√≥n `View()` que nos permite obtener una visualizaci√≥n tabular completa de c√≥mo se ve el conjunto de datos. La visualizaci√≥n desplegada tambi√©n la podemos obtener dando click sobre el nombre del data table en la venta de `Environment` de RStudio.  


## 3.5. Renombrando columnas de un data.table

Para simplificar el c√≥digo, es muy importante asegurarnos que los nombres de columna de nuestro data table sean *adecuados* (comienzan con una letra, utilizan √∫nicamente letras, n√∫meros y guiones bajos (_) en lugar de espacios, no utilizar caracteres epeciales, y son nombres cortos, claros y concretos). 

```setnames()``` es una funci√≥n que nos permitir√° cambiar uno o varios nombres de columna de un data.table de forma *segura*.
```{r}
setnames(dt, old = c("hombres", "mujeres"), new = c("pob_hombres", "pob mujeres"))
```

<br> 
```{r}
colnames(dt)
```

üí° Para sustituir un valor y reemplazarlo por otro valor en un vector, la `gsub()` resulta muy √∫til. En contexto, podemos utilizar `gsub()` para reemplazar un caracter especial que se repita en los nombres de columna de un data table.

<br> 
```{r}
setnames(dt,
         old = colnames(dt), 
         new = gsub(" ", "_", colnames(dt))) # Reemplaza espacios por un gui√≥n bajo en los nombres de columna del data table
```

<br> 
```{r}
colnames(dt)
```

<br> 

## 3.6. Utilizando `i` en un data table

üí° Recordemos que la forma general de sintaxis de un data table es `DT[i, j, by = k]`, y textualmente, se leer√≠a de la siguiente forma:

1. Toma `DT` 
3. Toma el subconjunto de filas `i` u ordena las filas usando las columnas `i`
3. Toma el subconjunto de columnas `j` o calcula las nuevas columnas `j`
4. Agrupando por las columnas `k`

<br>

* Tomando el subconjunto de filas `i`

Una √∫nica observaci√≥n bas√°ndonos en su √≠ndice
```{r}
dt[41, ]
```

<br>
Una secuencia de observaciones bas√°ndonos en sus √≠ndices
```{r}
dt[41:52, ]
```

<br>
Un conjunto de observaciones no secuenciales bas√°ndonos en su √≠ndices
```{r}
dt[c(41, 950, 1556), ]
```

<br>
Un conjunto de observaciones bas√°ndonos en una condici√≥n
```{r}
dt[entidad_federativa %in% c("Estados Unidos Mexicanos", "Ciudad de M√©xico", "M√©xico") & edad == 40, ]
```

<br>

* Ordenando las filas usando las columnas `i`

Con una variable de forma ascendente
```{r}
head(dt[order(pob_hombres), ])
```

<br>
Con una variable de forma descendente 
```{r}
head(dt[order(-pob_hombres), ])
```

<br>
Con dos variables de forma ascendente 
```{r}
head(dt[order(entidad_federativa, pob_hombres), ])
```

<br> 

## 3.7. Utilizando `j` en un data table

* Tomando el subconjunto de columnas `j`

Una √∫nica variable bas√°ndonos en su √≠ndice
```{r}
head(dt[, 2])
```

<br>
Una secuencia de variables bas√°ndonos en sus √≠ndices
```{r}
head(dt[, 3:4])
```

<br>
Un conjunto de variables no secuenciales bas√°ndonos en su √≠ndices
```{r}
head(dt[, c(1, 3:4)])
```

<br>
Una √∫nica variable bas√°ndonos en su nombre de columna
```{r}
head(dt[, .(entidad_federativa)])
```

<br>
Tambi√©n es posible escribir la instrucci√≥n as√≠: `dt[, .(entidad_federativa)]`. Observe que al ejecutar la instrucci√≥n sin el `.()`, el resultado es un vector. 

<br>
üí° La funci√≥n ```unique()``` devuelve todos los valores √∫nicos de un vector. Esta funci√≥n resulta √∫til para explorar r√°pidamente los valores √∫nicos de una variable categ√≥rica. 
```{r}
unique(dt[, entidad_federativa])
```

<br>
Un conjunto de variables no secuenciales bas√°ndonos en su nombre de columna.
```{r}
head(dt[, .(entidad_federativa, pob_hombres, pob_mujeres)]) 
```
üí° Tambi√©n es posible reordenar las columnas de un conjunto de datos de esta forma. 

<br>
Esta otra forma es tambi√©n v√°lida y debe ser utilizada en caso de que los nombres de columnas tengan caracteres especiales. 
```{r}
head(dt[, c("entidad_federativa", "pob_hombres", "pob_mujeres")]) 
```

<br>

* Calculando las nuevas columnas `j`

Al calcular una nueva columna en un data table, una iteraci√≥n por cada fila ocurre de forma impl√≠cita.

<br>
Calculando nueva variable desde 0 
```{r}
dt[, indice := 1:nrow(dt)]
head(dt)
```

<br>
Calculando nueva variable con variables ya existentes 
```{r}
dt[, pob_total := pob_hombres + pob_mujeres]
head(dt)
```
üí° **En R, las operaciones con `NA` siempre resultan en `NA`.**

<br>
Calculando variable con variables ya existentes y condicionales 
```{r}
# Se sobreescribe una variable ya existente (pob_total)
dt[, pob_hombres := ifelse(test = pob_hombres < 0, # ¬øLa poblaci√≥n de hombres en la fila es menor a 0?
                         yes = 0, # Si la condici√≥n es verdadera, devuelve 0 
                         no = pob_hombres)] # Si la condici√≥n es falsa, devuelve la misma poblaci√≥n de hombres en la fila
head(dt)
```

<br>
Para eliminar una variable, esta se debe de igualar al valor `NULL`.

```{r}
colnames(dt)
```

<br>
```{r}
dt[, indice := NULL]
colnames(dt)
```

<br>

## 3.8. Utilizando `k` en un data table

Antes de agrupar por las columnas `k`, es necesario indicar al menos una operaci√≥n con una columna `j`.

* Operando con las columnas `j`

Una √∫nica operaci√≥n
```{r}
dt[entidad_federativa != "Estados Unidos Mexicanos", sum(pob_hombres)]
```

<br>
```{r}
dt[, .N] # .N es un conteo de observaciones
```

<br>
M√∫ltiples operaciones
```{r}
dt[entidad_federativa == "Estados Unidos Mexicanos", .(sum(pob_hombres), sum(pob_mujeres))]
```

<br>
Renombrando las operaciones
```{r}
dt[entidad_federativa != "Estados Unidos Mexicanos", .(sum_pob_h = sum(pob_hombres), sum_pob_m = sum(pob_mujeres))]
```

<br>

* Agrupando por las columnas `k`

Por una √∫nica variable
```{r}
head(dt[, .(sum_pob_h = sum(pob_hombres), sum_pob_m = sum(pob_mujeres)), by = entidad_federativa])
```

<br> 
Por m√∫ltiples variables
```{r}
head(dt[, .(sum_pob_h = sum(pob_hombres), sum_pob_m = sum(pob_mujeres)), by = .(entidad_federativa, edad)])
```
En este caso, el resultado a la instrucci√≥n anterior luce igual al data table opriginal. 

<br> 

## üèã Ejercicio
1. Cree un nuevo proyecto.
2. Cree una nueva carpeta dentro del proyecto que se llame ‚Äúdatos‚Äù y ubique dentro de esta a los archivos pob_censo_2020_inegi.txt y lic_censo_2020_inegi.csv.
3. Cree una nueva carpeta dentro del proyecto que se llame "scripts" y cree un nuevo script dentro de esta. 
4. En el script, cargue el conjunto de datos del archivo pob_censo_2020_inegi.txt a R como data table.
5. En el script, utilizando el data table, programe el c√≥digo correspondiente para resolver lo siguiente:

   5.1. Asigne nuevos nombres de columnas a cada variable.
   
   5.2. Verifique que haya el mismo n√∫mero de observaciones por cada entidad federativa. 
   
   5.3. Ubique las observaciones y variables que contienen `NA`s y reempl√°ce los `NA`s por un valor que considere pertinente. 
   
   5.4. Responda: ¬øcu√°l es la entidad federativa cuya relaci√≥n hombres-mujeres es la m√°s alta a nivel nacional? La relaci√≥n hombres-mujeres refiere a cu√°ntos hombres hay por cada mujer en la entidad federativa).
   
   5.5. Cree un nuevo data table con la poblaci√≥n total de mujeres entre 18 y 65 a√±os por regi√≥n geogr√°fica y gu√°rdelo en un nuevo archivo csv dentro de la carpeta ‚Äúdatos‚Äù del proyecto. Puede consultar las entidades federativas que conforman cada regi√≥n geogr√°fica en el [Glosario del INEGI]("https://www.inegi.org.mx/app/glosario/default.html?p=ENIF2021").
   
   5.6. Cree un nuevo data table con la poblaci√≥n total de 18 a√±os por entidad federativa y en √©l cree una nueva variable que refiera al porcentaje que representa la poblaci√≥n de 18 a√±os de cada entidad federativa de la poblaci√≥n total de 18 a√±os a nivel nacional.
   
   5.7. Responda: ¬øcu√°l es la media de edad a nivel nacional?
6. Cree un segundo script dentro de la carpeta "scripts". 
7. En este segundo script, cargue los conjuntos de datos de los archivos pob_censo_2020_inegi.txt y lic_censo_2020_inegi.csv a R como data tables.
8. En este segundo script, utilizando ambos data tables, programe el c√≥digo correspondiente para resolver lo siguiente:
  
   8.1. Cree un nuevo data table con la poblaci√≥n total de mujeres de Aguascalientes por edad.
   
   8.2. Cree un nuevo data table con la poblaci√≥n total de mujeres de Aguascalientes que estudiaron una licenciatura (o equivalente) por edad.

<center>
![](https://c.tenor.com/rvNN3fvmjnaaAd/corgi-cute.gif)
</center>

## 3.9. Uni√≥n de data tables

Para esta secci√≥n, retomamos el inciso 8 del Ejercicio.
```{r}
dt_lic <- fread("./data/lic_censo_2020_inegi.csv", encoding = "UTF-8")
```
   
<br>  
```{r}
dt_pob_ags <- dt[entidad_federativa == "Aguascalientes", .(edad, pob_mujeres)]
dt_lic_ags <- dt_lic[ent_fed == "Aguascalientes" & sexo == "Mujeres", .(edad, estudiaron_licenciatura)]
```

<br>
Antes de unir dos data tables, debemos asegurarnos que la variable llave en ambos data tables sea del mismo tipo de dato.
```{r}
typeof(dt_pob_ags[, edad])
```

<br>
```{r}
typeof(dt_lic_ags[, edad])
```

<br>
```{r}
dt_pob_ags[, edad := ifelse(edad == "100 y m√°s", yes = "101", no = edad)]
dt_pob_ags[, edad := as.integer(edad)]
```

<br>
Unimos los data tables `dt_pob_ags` y `dt_lic_ags` conservando todos los valores del primer data table. 
```{r}
dt_merge <- merge(x = dt_pob_ags,
                  y = dt_lic_ags,
                  by.x = "edad", 
                  by.y = "edad", 
                  all.x = TRUE)
```

<br>
Unimos los data tables `dt_pob_ags` y `dt_lic_ags` conservando todos los valores del segundo data table. 
```{r}
dt_merge <- merge(x = dt_pob_ags,
                  y = dt_lic_ags,
                  by.x = "edad", 
                  by.y = "edad", 
                  all.y = TRUE)
```

<br>
Unimos los data tables `dt_pob_ags` y `dt_lic_ags` conservando todos los valores de ambos data tables. 
```{r}
dt_merge <- merge(x = dt_pob_ags,
                  y = dt_lic_ags,
                  by.x = "edad", 
                  by.y = "edad", 
                  all = TRUE)
```

## 3.10. Reorientaci√≥n de data tables

* De formato largo a ancho

Utilizamos la funci√≥n `dcast()`, que recibe como par√°metros: 

1. `data`: el objeto del data table que deseamos reorientar
2. `formula`: la f√≥rmula que indica el nombre de las variables que:
   
   * permaneceran como columnas (a la izquierda del `~` y separadas por un `+`) 
   
   * ser√°n reorientadas como nuevas columnas (a la derecha del `~` y separadas por un `+`) 
   
3. `value.var`: el nombre de la variable que contiene los valores de las variables que ser√°n reorientadas como nuevas columnas
4. `fun.aggregate` (en caso de que se est√© haciendo una agrupaci√≥n de valores): el nombre de la funci√≥n que se utilizar√° para agregar los valores de la variable indicada en `value.var` 

<br>
Sin agrupaci√≥n de valores
```{r}
dt_lic_short <- dcast(data = dt_lic,
                      formula = ent_fed+edad~sexo, 
                      value.var = "estudiaron_licenciatura")
head(dt_lic_short)
```

<br>
Con agrupaci√≥n de valores
```{r}
dt_lic_short <- dcast(data = dt_lic,
                      formula = ent_fed~sexo, 
                      value.var = "estudiaron_licenciatura",
                      fun.aggregate = sum)
head(dt_lic_short)
```

<br>

* De formato largo a ancho

Utilizamos la funci√≥n `melt()`, que recibe como par√°metros: 

1. `data`: el objeto del data table que deseamos reorientar
2. `id.vars`: qu√© variables permaneceran como columnas
3. `variable.name` (opcional): el nuevo nombre de la variable que contendr√° los nombres de las variables que ser√°n reorientadas como nuevas filas
4. `vvalue.name` (opcional): el nuevo nombre de la variable que contendr√° los valores de las variables que ser√°n reorientadas como nuevas filas

<br>
```{r}
dt_lic_long <- melt(data = dt_lic_short, 
                    id.vars = "ent_fed", 
                    variable.name = "sexo",
                    value.name = "estudiaron_lic")
head(dt_lic_long)
```

## 3.11. Manejo de variables categ√≥ricas (Bonus #1! üòä)

Cuando exportamos conjuntos de datos como data table, R lee no es capaz de identificar por defecto valores categ√≥ricos. 
```{r}
str(dt_lic)
```

<br>
En R, para poder identificar una varable categ√≥rica como tal, deben ser convertidas en fatcores. Esta conversi√≥n trae muchos beneficios a la hora de preprocesar y visualizar los datos, e incluso construir modelos estad√≠sticos con ellos.

Los factores son variables en R que toman un n√∫mero limitado de valores diferentes y se almacenan como un vector de valores enteros con un conjunto correspondiente de cadenas de caracteres para usar cuando se muestra el factor. 

La funci√≥n de `factor` se utiliza para crear un factor. El √∫nico par√°metro necesario para factorizar es un vector de valores que se devolver√° como un vector de valores de factor. 

Tanto las variables num√©ricas como las de cadenas caracteres se pueden convertir en factores, pero los niveles de un factor siempre ser√°n cadenas de caracteres en un orden predeterminado. Los `niveles` son otro par√°metro de la funci√≥n.

Los niveles de un factor se utilizan cuando se muestran los valores del factor. Puede cambiar estos niveles en el momento de crear un factor pasando un vector con los nuevos valores a trav√©s del para√°metro  `labels`. 

<br>
```{r}
sex_levels <- c("Hombres", "Mujeres")
sex_labels <- c("h", "m")
sex_var <- dt_lic[, sexo]
sex_factor <- factor(x = sex_var, levels = sex_levels, labels = sex_labels)
```

<br>
```{r}
dt_lic[, sexo := sex_factor]
str(dt_lic)
```